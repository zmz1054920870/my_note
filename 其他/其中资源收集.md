面试官你好，我叫张明柱，来自重庆万州。就职过3家公司，今天来面试贵公司的测试工程师职位。

上一家公司是成都晓多科技， 晓多科技是一家提供智能客服服务的厂商，业务涉及客户端、web、C端小程序。在晓多的日常工作是参与日常需求迭代会议，需求排期，需求评审，编写用例，跟进线上bug，bug分析。主要承接一些客户端和web端的功能测试，参与接口自动化前期框架的搭建，基于python 和pytest，allure,编写接口自动化脚本及脚本的维护。期间也从事过基于chrome远程调试协议，cef框架客户端的ui自动化脚本的编写，但是由于ui自动化收益太低，维护困难，该项目最后被放弃。期间也产出过一些工具脚本。近期针对去晓多化项目，编写过一个基于re正则模块，采用多进程的方式遍历全部前端文件，查找前端中包含晓多字符的前端代码，交予前端修改。

我性格开朗，喜欢和人打交道，平时喜欢骑车，钓鱼，打球。这是我一个简单的自我介绍。您看我这边还需要做什么补充？

在晓多主要承接一些客户端和web端的测试功能测试

SOP项目

qps大概，2000-3000。并发数当时设置 的是200-1500



locust用一台就够了   

压测机linux 8核CPU

locust是基于协程的，一次只能使用一个核，单台8C的压测机可以启动8个slave一个master（超超是启动了1个master4个slave）

分析为什么 ：启动多个locust slave和使用单个差距不大

原因：可能是由于单台压测机的网路I/O

locust的监控上显示的数据和真实的数据量是存在差异的，会比实际的低一些。我们可以通过nginx的请求日志，通过tail ，awk，uniq等一些列操作，过滤分析出真实的数据



关注点就是
1.当前服务器负载
2.sop商品推荐的微服务内存占用
3.rps高了之后请求的响应时间是否满足阿里要求?（阿里要求响应时间不能高于200ms）
4.tp99，tp90的概念

5. 负载的概念背一下，然后sop涉及到了一个微服务，查看那个微服务的内存的方法记一下







1)我会Linux系统操作和相关命令的使用，项目中搭建过测试环境。

2)用过My[SQL](http://java.tedu.cn/data/131405.html)数据库，使用SQL语句进行数据查询，有时候测试需要进行提交数据和查询数据的对比时，在数据库中查询数据。

3)我会[Python](http://sh.tedu.cn/python/)开发语言，可以用于Selenium的测试脚本编写。项目要求对一部分固定的功能进行自动化测试脚本的实现，使用unittest框架，脚本中插入断言和引入外部数据文件，导出过测试报告。

4)按照项目要求，对系统传输中的敏感数据进行检查和对比。会使用Postman进行接口的数据请求和查看服务器的响应结果，使用Fiddler进行数据抓包，分析敏感数据是否进行加密处理。

5)项目中配合开发和运维做系统的一些性能测试。使用JMeter/Loadrunner对系统的操作复杂和高并发业务进行性能测试的执行。

6)项目中，我全程参与了需求评审，测试计划的设定，编写测试用例，执行测试、提交Bug，我们都用禅道/JIRA进行用例和缺陷的管理和跟踪。

7)对于测试中要搭建的测试开发的框架Selenium、requests、APPium，环境自己搭建。最近做过的一个项目是XXXXX管理系统，在其中负责XXXX模块的测试工作，他的主要功能是XXXX，设计和编写了XXX条用例，发现了XXX个bug。我的自我介绍到此结束/就这么多，面试官，您看有什么需要我补充的，或者您想要知道更详细的的？





长沙二三三网校   顺天国际财富中心

广州果肉网校  上面有一个人民公园， 中山五路  中旅商业城 

 



step1：连接数据库
step2：创建游标对象
step3：对数据库进行增删改查
step4：关闭游标
step5：关闭连接

```
conn = pymysql.connect(
    host='localhost',
    user='root',
    password='redhat',
    db='helloTest',
    charset='utf8',
    autocommit=True,    # 如果插入数据，， 是否自动提交? 和conn.commit()功能一致。
    
    
cur = conn.cursor()


```









```
# 查看所有的资源信息
kubectl get all

# 查看pod列表
kubectl get pod

# 显示pod节点的标签信息
kubectl get pod --show-labels

# 根据指定标签匹配到具体的pod
kubectl get pods -l app=example

# 查看node节点列表
kubectl get node 

# 显示node节点的标签信息
kubectl get node --show-labels

# 查看pod详细信息，也就是可以查看pod具体运行在哪个节点上（ip地址信息）
kubectl get pod -o wide

# 重启
kubectl rollout restart deploy {your_deployment_name}

# 修改deploy
kubectl -n namespace edit deploy xxx

# 进入容器
k -n namespace exec -it xxxx
```



![image-20210923124341121](image-20210923124341121.png)







#  时间不够如何做好测试



#### 1. 划重点测试

时间不足，那么一定要在有限的时间内保证重点功能、风险高的功能得到充分的测试。

- **涉及金钱的功能**

	- 涉及金钱的都不是小事

- **核心业务流程**

	- 每一次提测， 都会只要有一个核心的业务。一旦这个核心流程出现问题，那么这次发布，就没意义了

- **用户使用频率**

	



#### 2. 尽可能的提前介入

- **提前准备数据**
	- 如果一些导入，导出。当研发产品确定了导入导出模板文件以后。我们就可以着手准备测试数据了
- **接口测试**
	- 因为一般接口，是会先于接面出来的。

#### 3. 优化用例

由于需要尽可能提前介入，也许就没有时间编写详细的测试用例。这种情况下可以使用测试点代替测试用例。
运用思维导图工具 xmind 梳理需求功能点（接口功能点）的时候，尽可能详尽，把测试需要关注的点都列出来。
这样时间不足以编写详细用例的情况下，测试点也就可以代替用例发挥测试指导作用了。

#### 4. 加强沟通

这个时候，如非必要，不要采用钉钉或者飞书这些软件进行沟通。直接采用当面沟通。在测试过程如遇见阻塞 或自己无法解决的问题，及时找组长和 项目经理沟通，给你协调资源



#### 5. 加班

由于本来时间已经很少了，这个时候，就要将整个测试过程进行拆分，理一份合理的工作计划表。如当天任务未完成，那就只有加班处理了





## 你有什么想问的？

1、 我们部门的研发测试占比是多少呢

2、 公司有哪些技术提升渠道呢？可供我学习，提升的

3、 请问我什么时候能知道结果呢？

4、 请问，晋升渠道





## 测试结束的标志

1、 全部测试用例执行完成

2、 严重级别以上bug全部修复，一般级别的bug修复要达到95%及以上

3、 这些未修改的bug都要被扭转到对应的状态，如挂起，或者展缓修复。  针对这些展缓修复的的bug都要有详尽的解释和说明。

4、 回归测试执行执行完成

5、 相应报告已发送

6、项目处于试运行或者上线阶段。比如灰度发布，继续关注运行的问题，即使记录跟进bug







## bug等级

L0 ： fatal（致命）： 如系统出现瘫痪、主功能缺失，有关金钱的，频繁闪退， 一旦发现立即中止当前版本测试。 立即处理

L1： critical(严重)：测试的主功能存在部分缺失。如某功能的某一级菜单不能使用，但不影响其他功能测试。  -- 这种不影响其他功能测试的，可以继续进行测试

L2： major(一般) ：功能没有完全实现，但是不影响使用。如果一些边界错误，错误格式，查询时间过长                     --  这种bug的解决率关系版本的优化程度

L3： minor(微小)， 对产品影响小，其他bug解决之后，在解决该类bug。如一些提示性的bug。如国内产品，你在提示的时候给别人一串英文。有些地方需要提示然而你却没有给提示  --- 



#### [禅道Bug等级划分标准](https://www.cnblogs.com/mawenqiangios/p/12917475.html)

一、严重程度

P1：致命（该问题在测试中较少出现，一旦出现应立即中止当前版本测试）

阻碍开发或测试工作的问题；造成系统崩溃、死机、死循环，导致数据库数据丢失， 与数据库连接错误，主要功能丧失，基本模块缺失等问题。如：代码错误、死循环、数 据库发生死锁、重要的一级菜单功能不能使用、内存泄漏、严重计算错误、无法登录、无法正常退出、功能设计与需求严重不符，模块无法启动或调用，程序重启、自动退出， 关联程序间调用冲突等。

P2：严重（不影响其他功能测试的情况下可以继续该版本测试）

系统主要功能部分丧失、数据库保存调用错误、用户数据丢失，一级功能菜单不能使用 但是不影响其他功能的测试。安全问题、稳定性等。如：软件中数据保存后数据库中显 示错误，用户所要求的功能缺失，程序接口错误，数值计算统计错误等

P3：一般（实际测试中存在最多，解决率关系版本的优化程度）

功能没有完全实现但是不影响使用，功能菜单存在缺陷但不会影响系统稳定性。如：操作时间长、查询时间长、格式错误、边界条件错误，删除没有确认框、数据库表中字段过多、容错性不好、大数据无响应或没有滚动条等

P4：建议（测试初期较多，优先程度较低；在测试后期出现较少，应及时处理）

界面、性能缺陷，建议类问题，不影响操作功能的执行，可以优化性能的方案等。如：错别字、界面格式不规范，页面显示重叠、不该显示的要隐藏，描述不清楚，提示语丢 失，文字排列不整齐，光标位置不正确，用户体验感受不好，可以优化性能的方案等





## 什么是闭包

内部函数对外部函数的调用





## 测试数据你放在哪里

1.对于账号密码，这种管全局的参数，可以用命令行参数，单独抽出来，写的配置文件里（如ini）
2.对于一些一次性消耗的数据，比如注册，每次注册不一样的数，可以用随机函数生成
3.对于一个接口有多组测试的参数，可以参数化，数据放yaml,text,json,excel都可以
4.对于可以反复使用的数据，比如订单的各种状态需要造数据的情况，可以放到数据库，每次数据初始化，用完后再清理
5.对于邮箱配置的一些参数，可以用ini配置文件
6.对于全部是独立的接口项目，可以用数据驱动方式，用excel/csv管理测试的接口数据
7.对于少量的静态数据，比如一个接口的测试数据，也就2-3组，可以写到py脚本的开头，十年八年都不会变更的







**给你一个水杯 你怎么测**

首先，水杯他主要是用来装水  、 送水、 喝水		 -- 分析一波，也给自己一点思考的时间

功能性方面：

1、 能否装水

2、 我们倒水的时候，能否立得住

3、能否用于送水。

4、 能否喝得到水

5、 是否漏水

5、 如果水杯有隔热材料，在倒入开水以后，是否能够用手拿被子



界面上：

1、 水杯的颜色是否符合审美

2、 logo位置是否正确

3、 水杯外观是否美观

4、 水杯上的文案是否合理，是否有错别字

5、 针对一些注意事项是否有提醒。。



性能上：

1、 水杯能装多少水

2、  多长时间保证水不会渗漏



安全性：

1、水杯材质是否有毒

2、 喝水时候，是否会伤到嘴



兼容性：

1、 能够用来到可乐、啤酒、咖啡



易用性：

1、 倒水是否方便

2、 送水是否方便

3、 喝水是否方便





https://www.cnblogs.com/yoyoketang/p/10220061.html  悠悠

https://www.cnblogs.com/yoyoketang/p/14084401.html

https://www.cnblogs.com/yoyoketang/p/15132889.html

## 接口测试

一、功能

1、 接口是否按照按照设计文档来实现的，比如接口文档中 参数是username ， 而实际使用的是user。

2、 

https://blog.csdn.net/sun_qian_li/article/details/105569957



https://www.cnblogs.com/c-jw/p/13919701.html

https://www.job592.com/pay/ms.html?shareid=762063







#### tcp和upd的不同和相似之处

https://blog.csdn.net/qq_43685242/article/details/108490347?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1.no_search_link&spm=1001.2101.3001.4242



产品主要解决的是，客服人力成本的问题，如夜间无人值守时， 晓多机器人可以进行接待。    当咨询量较大时，如618，双11，客服咨询量较大的时候，人工接待完全无法满足线上的咨询回复，造成订单的流失，此时晓多机器人可以棒客服减压，帮忙进行接待。





#### 你是怎么开展ui自动化测试





#### 自动化测试从什么时候开始介入





#### 性能测试

1、 tp99 tp95

2、 linux相关命令

3、 工具locust， locust只使用了一个核，采用的是协程的方式







#### HTTP 和 HTTPS 的不同

百度













## 用例设计

一个bug ：当给三个人同时发送短信的实话，会崩溃。。 进行回归，你评估了一下，这个bugfix 要5天上线，但是由于，影响较大，产品那边要求3天上线。。你怎么保证质量和用例的世界

#### 功能

- 测试给3人同时发送短信，能否发送成功，且无其他异常
- 测试给1人发送短信，能发送成功，且无其他异常
- 测试给2人发送短信，能否发送成功，且无其他异常
- 测试给超过3人同时发送短信，能否发送成都，且无其他异常
- 测试在编辑短信过程中，是否会造成司机
- 回测第一轮测试的用例（主功能）及 发送短信相关的其他用例

#### 性能

- 测试能同时给多少人编辑短信，且有电话接入时不会出现卡顿

#### 稳定

- 测试bug修复以后， 会不会对其他模块有影响，可以check一下其他相关的功能模块，测试一下主功能即可

## 保障按期发布

#### 用例优化

1、 由于测试周期短，只能进行bug的和核心功能进行覆盖.不能进行像第一轮一样全部用例执行

#### 自动化接入

1、 如前面的用例已实现自动化，可以介入自动化

#### 沟通

1、 工期紧张， 有问题，在允许的范围内，直接当面和研发进行沟通。 如果自己在测试过程中，存在无法解决的问题的话，及时和组内组长和负责人进行沟通，协调资源进行排查



#### 测试提前

1、 在研发进行修复bug期间，我们可以见测试数据进行提前准备



















# 一、浅拷贝和深拷贝

**首先深拷贝和浅拷贝都是对象的拷贝，都会生成一个看起来相同的对象，他们本质的区别是拷贝出来的对象的地址是否和原对象一样，也就是地址的复制还是值的复制的区别。**

首先我们要知道一个概念，那就是**什么是可变对象，什么是不可变对象：**

可变对象是指，一个对象在不改变其所指向的地址的前提下，可以修改其所指向的地址中的值；

不可变对象是指，一个对象所指向的地址上值是不能修改的，如果你修改了这个对象的值，那么它指向的地址就改变了，相当于你把这个对象指向的值复制出来一份，然后做了修改后存到另一个地址上了，但是可变对象就不会做这样的动作，而是直接在对象所指的地址上把值给改变了，而这个对象依然指向这个地址。



列表，字典就是一个可变对象，他们里面的值发送改变，但是列表对象的id是不会变的.

🔺其实我们现在学到的大部分数据结构都是可变对象。我们定义的类也是可变对象

```python
a = {"a":1, "b":2}
b = a.copy()

>>> id(a)
1765374957248

>>> id(b)
1765374956168

>>> b['b']=3

>>> id(a)
1765374957248

>>> id(b)
1765374956168

=======完美分割线=========
a = [1, 2, 3]
b = a.copy()

>>> id(a)
1765375321480
>>> id(b)
1765375174024

>>> a[0] = 10
>>> id(a)
1765375321480
>>> id(b)
1765375174024

=======完美分割线:字典的浅拷贝=========
a = {"a":{"b":1}}
b = a.copy()
>>> id(a)
1765375324448
>>> id(b)
1765374956240
>>> a['a']['b'] = 2

>>> a
{'a': {'b': 2}}
>>> b
{'a': {'b': 2}}

```

**如果一个对象里面嵌套了一个可变对象。当我们修改这个可变对象里面的元素的值的时候，其他浅拷贝的对象也会跟着发送改变**

**补充说一下元组浅拷贝以后id不会变，相当于赋值操作**

```python
# 补充说明一下，元组就两个方法一个count统计元素的个数,一个index返回元素的索引
import copy
a = ([1, 2], 3, [4, 5])
b = copy.copy(a)

>>> id(a)
1765375380864
>>> id(b)
1765375380864
```











**深拷贝和浅拷贝需要注意的地方就是可变元素的拷贝：**

在浅拷贝时，拷贝出来的新对象的地址和原对象是不一样的，但是新对象里面的可变元素（如列表）的地址和原对象里的可变元素的地址是相同的，也就是说浅拷贝它拷贝的是浅层次的数据结构（不可变元素），对象里的可变元素作为深层次的数据结构并没有被拷贝到新地址里面去，而是和原对象里的可变元素指向同一个地址，所以在新对象或原对象里对这个可变元素做修改时，两个对象是同时改变的，但是深拷贝不会这样，这个是浅拷贝相对于深拷贝最根本的区别。



浅拷贝的时候，我们拷贝的对象和原对象的内存id是不一样的，但是如果原对象里面还有一个可变对象，比如列表，在浅拷贝的时候，这里面的可变对象id和原对象里面的id是一样的。这就造成了一个问题。当我们修改这里值的时候，原对象和浅拷贝对象都会发生改变。而深拷贝就不会有这样的问题



一般我们说的深拷贝和浅拷贝，就是针对一个列表里面的可变元素里面的值（列表）

常见的形式是这样的 [[1, 2, 3], 4, [5, 6, 7]] 这种格式的数据就要警惕深拷贝和浅拷贝影响了



**浅拷贝的例子**

```python
import copy
a = [[1, 2, 3], 44, [5, 6, 7]]
b = a[:]						# 浅拷贝
c = a[0:1]						# 浅拷贝
d = a.copy()					# 浅拷贝
e = copy.copy(a)				# 浅拷贝

>>> a[0][0] = 10				# 后面的b c d e都会跟着变

>>> b
[[10, 2, 3], 44, [5, 6, 7]]

>>> c
[[10, 2, 3], 44, [5, 6, 7]]

>>> d
[[10, 2, 3], 44, [5, 6, 7]]

>>> e
[[10, 2, 3]]


#  我们再做如下修改
>>> b[0][0] = 100

>>> a
[[100, 2, 3], 44, [5, 6, 7]]

>>> b
[[100, 2, 3], 44, [5, 6, 7]]

>>> c
[[100, 2, 3]]

>>> d
[[100, 2, 3], 44, [5, 6, 7]]

>>> e
[[100, 2, 3], 44, [5, 6, 7]]
```



**深拷贝**

```python
import copy
a = [[1, 2, 3], 44, [5, 6, 7]]
b = copy.deepcopy(a)

>>> a[0][0] = 100
>>> a
[[100, 2, 3], 44, [5, 6, 7]]
>>> b
[[1, 2, 3], 44, [5, 6, 7]]
```





#### 面试官问你还有什么问题要问？

这个时候一定要问：这其实也是在考研你对测试 这个行业的熟悉成都

1、 研发和测试的占比 （这个很专业 -- 一般能问这个问题的）

2、 测试是分组配合还是全部统一协调

3、 测试深度要求





#### 



